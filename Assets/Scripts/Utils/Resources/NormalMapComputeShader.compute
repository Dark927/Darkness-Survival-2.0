#pragma kernel GaussianBlur
#pragma kernel NormalKernel
#pragma target cs_5_0 // or cs_5_0 for compute shaders

// Texture inputs and outputs
Texture2D<float4> InputTexture;
RWTexture2D<float> TempTexture;
RWTexture2D<float4> OutputTexture;

SamplerState linearClampSampler {
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = TEXTURE_ADDRESS_WRAP;
    AddressV = TEXTURE_ADDRESS_WRAP;
};


// Parameters
uint _Width;
uint _Height;
float _Intensity;
float _Smoothness;

float Luminance(float3 color)
{
    return dot(color, float3(0.299f, 0.587f, 0.114f));
}

[numthreads(8, 8, 1)]
void GaussianBlur(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _Width || id.y >= _Height) return;


    _Smoothness = 3;
    // Kernel radius for Gaussian blur
    int kernelRadius = (int)(3.0 * _Smoothness);
    float sigmaSq = _Smoothness * _Smoothness;

    // Gaussian smoothing
    float sum = 0.0;
    float weightSum = 0.0;

    
    for (int x = -kernelRadius; x <= kernelRadius; x++) {
        for (int y = -kernelRadius; y <= kernelRadius; y++) {
            float weight = exp(-((x * x + y * y) / (2.0 * sigmaSq)));
            float4 sample = InputTexture.SampleLevel(linearClampSampler, float2((id.x + x) / (float)_Width, (id.y + y) / (float)_Height), 0);
            sum += Luminance(sample.rgb) * weight; // Assuming grayscale input
            weightSum += weight;
        }
    }

    float smoothedValue = sum / weightSum;

    // Store the smoothed value in the temporary texture
    TempTexture[id.xy] = smoothedValue;
}

[numthreads(8, 8, 1)]
void NormalKernel(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _Width || id.y >= _Height) return;

    // Sobel operator kernels
    float c[3][3];

    [unroll]
    for (int i = 0; i < 3; i++) {
        [unroll]
        for (int j = 0; j < 3; j++) {
            int2 uv = id.xy + int2(j-1, i-1);
            c[i][j] = TempTexture[uv];
        }
    }
    float gX =  -1.0f*c[0][0] - 2.0f*c[1][0] - 1.0f*c[2][0] 
                +1.0f*c[0][2] + 2.0f*c[1][2] + 1.0f*c[2][2];

    float gY =  -1.0f*c[2][0] - 2.0f*c[2][1] - 1.0f*c[2][1] 
                +1.0f*c[0][0] + 2.0f*c[0][1] + 1.0f*c[0][2];

    gX *= _Intensity;
    gY *= _Intensity;
    float3 normal = float3(gX,gY,1);
    normal = normalize(normal);
    normal = (normal * 0.5) + 0.5;
    OutputTexture[id.xy] = float4(normal,1.0);
}