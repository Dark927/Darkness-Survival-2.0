#pragma kernel GaussianBlur
#pragma kernel NormalKernel
#pragma target cs_5_0 // or cs_5_0 for compute shaders

// Texture inputs and outputs
Texture2D<float4> InputTexture;
RWTexture2D<float> TempTexture;
RWTexture2D<float4> OutputTexture;

int Resolution = 256;
Texture2D<float> CurveLUTTexture;

SamplerState LUTSampler {
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = TEXTURE_ADDRESS_WRAP;
    AddressV = TEXTURE_ADDRESS_WRAP;
};

SamplerState linearClampSampler {
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = TEXTURE_ADDRESS_WRAP;
    AddressV = TEXTURE_ADDRESS_WRAP;
};


// Parameters
uint _Width;
uint _Height;
float _Intensity;
float _Smoothness;


float LUT(float bw){
    return CurveLUTTexture.SampleLevel(linearClampSampler, float2(bw, 0.0), 0);
}

float Luminance(float4 color)
{
    float bw = dot(color.rgb, float3(0.299f, 0.587f, 0.114f)) * color.a + color.a / 255;
    return LUT(bw);
}


[numthreads(8, 8, 1)]
void GaussianBlur(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _Width || id.y >= _Height) return;


    //_Smoothness = 3;
    // Kernel radius for Gaussian blur
    int kernelRadius = (int)(3.0 * _Smoothness);
    float sigmaSq = _Smoothness * _Smoothness;

    // Gaussian smoothing
    float sum = 0.0;
    float weightSum = 0.0;

    //if smoothness is 0, then sample as grayscale
    if(kernelRadius == 0){
        float4 sample = InputTexture[id.xy];
        TempTexture[id.xy] = Luminance(sample);
        return;
    }
    
    for (int x = -kernelRadius; x <= kernelRadius; x++) {
        for (int y = -kernelRadius; y <= kernelRadius; y++) {
            float weight = exp(-((x * x + y * y) / (2.0 * sigmaSq)));


            int wrappedX = (id.x + x + _Width) % _Width;
            int wrappedY = (id.y + y + _Height) % _Height;
            float4 sample = InputTexture[int2(wrappedX,wrappedY)];
            //float4 sample = InputTexture.SampleLevel(linearClampSampler, float2((id.x + x) / (float)_Width, (id.y + y) / (float)_Height), 0);
            sum += Luminance(sample) * weight; // Assuming grayscale input
            weightSum += weight;
        }
    }

    float smoothedValue = sum / weightSum;

    // Store the smoothed value in the temporary texture
    TempTexture[id.xy] = smoothedValue;
}

[numthreads(8, 8, 1)]
void NormalKernel(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _Width || id.y >= _Height) return;

    // Sobel operator kernels
    float c[3][3];

    [unroll]
    for (int i = 0; i < 3; i++) {
        [unroll]
        for (int j = 0; j < 3; j++) {
            int2 uv = id.xy + int2(j-1, i-1);
            c[i][j] = TempTexture[uv];
        }
    }
    float gX =  -1.0f*c[0][0] - 2.0f*c[1][0] - 1.0f*c[2][0] 
                +1.0f*c[0][2] + 2.0f*c[1][2] + 1.0f*c[2][2];

    float gY =  -1.0f*c[2][0] - 2.0f*c[2][1] - 1.0f*c[2][1] 
                +1.0f*c[0][0] + 2.0f*c[0][1] + 1.0f*c[0][2];

    gX *= _Intensity;
    gY *= _Intensity;
    float3 normal = float3(gX,gY,1);
    normal = normalize(normal);
    normal.x *= -1;
    normal = (normal * 0.5) + 0.5;
    OutputTexture[id.xy] = float4(normal,1.0);
    //OutputTexture[id.xy] = TempTexture[id.xy];//float4(normal,1.0);
    //OutputTexture[id.xy] = InputTexture.SampleLevel(linearClampSampler, float2((id.x) / (float)_Width, (id.y) / (float)_Height), 0);
}